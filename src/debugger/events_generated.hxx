// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_
#define FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

namespace Debugger {

struct GetStateRequest;
struct GetStateRequestBuilder;
struct GetStateRequestT;

struct GetStateResponse;
struct GetStateResponseBuilder;
struct GetStateResponseT;

struct PauseRequest;
struct PauseRequestBuilder;
struct PauseRequestT;

struct RunRequest;
struct RunRequestBuilder;
struct RunRequestT;

struct WriteMemoryRequest;
struct WriteMemoryRequestBuilder;
struct WriteMemoryRequestT;

struct WriteMemoryResponse;
struct WriteMemoryResponseBuilder;
struct WriteMemoryResponseT;

struct ReadMemoryRequest;
struct ReadMemoryRequestBuilder;
struct ReadMemoryRequestT;

struct ReadMemoryResponse;
struct ReadMemoryResponseBuilder;
struct ReadMemoryResponseT;

struct WriteRegisterRequest;
struct WriteRegisterRequestBuilder;
struct WriteRegisterRequestT;

struct WriteRegisterResponse;
struct WriteRegisterResponseBuilder;
struct WriteRegisterResponseT;

struct ReadRegisterRequest;
struct ReadRegisterRequestBuilder;
struct ReadRegisterRequestT;

struct ReadRegisterResponse;
struct ReadRegisterResponseBuilder;
struct ReadRegisterResponseT;

struct ApplicationExit;
struct ApplicationExitBuilder;
struct ApplicationExitT;

struct EmulationStatus;
struct EmulationStatusBuilder;
struct EmulationStatusT;

struct DebugEvent;
struct DebugEventBuilder;
struct DebugEventT;

enum State : uint32_t {
  State_None = 0,
  State_Running = 1,
  State_Paused = 2,
  State_MIN = State_None,
  State_MAX = State_Paused
};

inline const State (&EnumValuesState())[3] {
  static const State values[] = {
    State_None,
    State_Running,
    State_Paused
  };
  return values;
}

inline const char * const *EnumNamesState() {
  static const char * const names[4] = {
    "None",
    "Running",
    "Paused",
    nullptr
  };
  return names;
}

inline const char *EnumNameState(State e) {
  if (::flatbuffers::IsOutRange(e, State_None, State_Paused)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesState()[index];
}

enum Event : uint8_t {
  Event_NONE = 0,
  Event_PauseRequest = 1,
  Event_RunRequest = 2,
  Event_GetStateRequest = 3,
  Event_GetStateResponse = 4,
  Event_WriteMemoryRequest = 5,
  Event_WriteMemoryResponse = 6,
  Event_ReadMemoryRequest = 7,
  Event_ReadMemoryResponse = 8,
  Event_WriteRegisterRequest = 9,
  Event_WriteRegisterResponse = 10,
  Event_ReadRegisterRequest = 11,
  Event_ReadRegisterResponse = 12,
  Event_ApplicationExit = 13,
  Event_EmulationStatus = 14,
  Event_MIN = Event_NONE,
  Event_MAX = Event_EmulationStatus
};

inline const Event (&EnumValuesEvent())[15] {
  static const Event values[] = {
    Event_NONE,
    Event_PauseRequest,
    Event_RunRequest,
    Event_GetStateRequest,
    Event_GetStateResponse,
    Event_WriteMemoryRequest,
    Event_WriteMemoryResponse,
    Event_ReadMemoryRequest,
    Event_ReadMemoryResponse,
    Event_WriteRegisterRequest,
    Event_WriteRegisterResponse,
    Event_ReadRegisterRequest,
    Event_ReadRegisterResponse,
    Event_ApplicationExit,
    Event_EmulationStatus
  };
  return values;
}

inline const char * const *EnumNamesEvent() {
  static const char * const names[16] = {
    "NONE",
    "PauseRequest",
    "RunRequest",
    "GetStateRequest",
    "GetStateResponse",
    "WriteMemoryRequest",
    "WriteMemoryResponse",
    "ReadMemoryRequest",
    "ReadMemoryResponse",
    "WriteRegisterRequest",
    "WriteRegisterResponse",
    "ReadRegisterRequest",
    "ReadRegisterResponse",
    "ApplicationExit",
    "EmulationStatus",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvent(Event e) {
  if (::flatbuffers::IsOutRange(e, Event_NONE, Event_EmulationStatus)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvent()[index];
}

template<typename T> struct EventTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventTraits<Debugger::PauseRequest> {
  static const Event enum_value = Event_PauseRequest;
};

template<> struct EventTraits<Debugger::RunRequest> {
  static const Event enum_value = Event_RunRequest;
};

template<> struct EventTraits<Debugger::GetStateRequest> {
  static const Event enum_value = Event_GetStateRequest;
};

template<> struct EventTraits<Debugger::GetStateResponse> {
  static const Event enum_value = Event_GetStateResponse;
};

template<> struct EventTraits<Debugger::WriteMemoryRequest> {
  static const Event enum_value = Event_WriteMemoryRequest;
};

template<> struct EventTraits<Debugger::WriteMemoryResponse> {
  static const Event enum_value = Event_WriteMemoryResponse;
};

template<> struct EventTraits<Debugger::ReadMemoryRequest> {
  static const Event enum_value = Event_ReadMemoryRequest;
};

template<> struct EventTraits<Debugger::ReadMemoryResponse> {
  static const Event enum_value = Event_ReadMemoryResponse;
};

template<> struct EventTraits<Debugger::WriteRegisterRequest> {
  static const Event enum_value = Event_WriteRegisterRequest;
};

template<> struct EventTraits<Debugger::WriteRegisterResponse> {
  static const Event enum_value = Event_WriteRegisterResponse;
};

template<> struct EventTraits<Debugger::ReadRegisterRequest> {
  static const Event enum_value = Event_ReadRegisterRequest;
};

template<> struct EventTraits<Debugger::ReadRegisterResponse> {
  static const Event enum_value = Event_ReadRegisterResponse;
};

template<> struct EventTraits<Debugger::ApplicationExit> {
  static const Event enum_value = Event_ApplicationExit;
};

template<> struct EventTraits<Debugger::EmulationStatus> {
  static const Event enum_value = Event_EmulationStatus;
};

template<typename T> struct EventUnionTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventUnionTraits<Debugger::PauseRequestT> {
  static const Event enum_value = Event_PauseRequest;
};

template<> struct EventUnionTraits<Debugger::RunRequestT> {
  static const Event enum_value = Event_RunRequest;
};

template<> struct EventUnionTraits<Debugger::GetStateRequestT> {
  static const Event enum_value = Event_GetStateRequest;
};

template<> struct EventUnionTraits<Debugger::GetStateResponseT> {
  static const Event enum_value = Event_GetStateResponse;
};

template<> struct EventUnionTraits<Debugger::WriteMemoryRequestT> {
  static const Event enum_value = Event_WriteMemoryRequest;
};

template<> struct EventUnionTraits<Debugger::WriteMemoryResponseT> {
  static const Event enum_value = Event_WriteMemoryResponse;
};

template<> struct EventUnionTraits<Debugger::ReadMemoryRequestT> {
  static const Event enum_value = Event_ReadMemoryRequest;
};

template<> struct EventUnionTraits<Debugger::ReadMemoryResponseT> {
  static const Event enum_value = Event_ReadMemoryResponse;
};

template<> struct EventUnionTraits<Debugger::WriteRegisterRequestT> {
  static const Event enum_value = Event_WriteRegisterRequest;
};

template<> struct EventUnionTraits<Debugger::WriteRegisterResponseT> {
  static const Event enum_value = Event_WriteRegisterResponse;
};

template<> struct EventUnionTraits<Debugger::ReadRegisterRequestT> {
  static const Event enum_value = Event_ReadRegisterRequest;
};

template<> struct EventUnionTraits<Debugger::ReadRegisterResponseT> {
  static const Event enum_value = Event_ReadRegisterResponse;
};

template<> struct EventUnionTraits<Debugger::ApplicationExitT> {
  static const Event enum_value = Event_ApplicationExit;
};

template<> struct EventUnionTraits<Debugger::EmulationStatusT> {
  static const Event enum_value = Event_EmulationStatus;
};

struct EventUnion {
  Event type;
  void *value;

  EventUnion() : type(Event_NONE), value(nullptr) {}
  EventUnion(EventUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Event_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventUnion(const EventUnion &);
  EventUnion &operator=(const EventUnion &u)
    { EventUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventUnion &operator=(EventUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = EventUnionTraits<RT>::enum_value;
    if (type != Event_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  Debugger::PauseRequestT *AsPauseRequest() {
    return type == Event_PauseRequest ?
      reinterpret_cast<Debugger::PauseRequestT *>(value) : nullptr;
  }
  const Debugger::PauseRequestT *AsPauseRequest() const {
    return type == Event_PauseRequest ?
      reinterpret_cast<const Debugger::PauseRequestT *>(value) : nullptr;
  }
  Debugger::RunRequestT *AsRunRequest() {
    return type == Event_RunRequest ?
      reinterpret_cast<Debugger::RunRequestT *>(value) : nullptr;
  }
  const Debugger::RunRequestT *AsRunRequest() const {
    return type == Event_RunRequest ?
      reinterpret_cast<const Debugger::RunRequestT *>(value) : nullptr;
  }
  Debugger::GetStateRequestT *AsGetStateRequest() {
    return type == Event_GetStateRequest ?
      reinterpret_cast<Debugger::GetStateRequestT *>(value) : nullptr;
  }
  const Debugger::GetStateRequestT *AsGetStateRequest() const {
    return type == Event_GetStateRequest ?
      reinterpret_cast<const Debugger::GetStateRequestT *>(value) : nullptr;
  }
  Debugger::GetStateResponseT *AsGetStateResponse() {
    return type == Event_GetStateResponse ?
      reinterpret_cast<Debugger::GetStateResponseT *>(value) : nullptr;
  }
  const Debugger::GetStateResponseT *AsGetStateResponse() const {
    return type == Event_GetStateResponse ?
      reinterpret_cast<const Debugger::GetStateResponseT *>(value) : nullptr;
  }
  Debugger::WriteMemoryRequestT *AsWriteMemoryRequest() {
    return type == Event_WriteMemoryRequest ?
      reinterpret_cast<Debugger::WriteMemoryRequestT *>(value) : nullptr;
  }
  const Debugger::WriteMemoryRequestT *AsWriteMemoryRequest() const {
    return type == Event_WriteMemoryRequest ?
      reinterpret_cast<const Debugger::WriteMemoryRequestT *>(value) : nullptr;
  }
  Debugger::WriteMemoryResponseT *AsWriteMemoryResponse() {
    return type == Event_WriteMemoryResponse ?
      reinterpret_cast<Debugger::WriteMemoryResponseT *>(value) : nullptr;
  }
  const Debugger::WriteMemoryResponseT *AsWriteMemoryResponse() const {
    return type == Event_WriteMemoryResponse ?
      reinterpret_cast<const Debugger::WriteMemoryResponseT *>(value) : nullptr;
  }
  Debugger::ReadMemoryRequestT *AsReadMemoryRequest() {
    return type == Event_ReadMemoryRequest ?
      reinterpret_cast<Debugger::ReadMemoryRequestT *>(value) : nullptr;
  }
  const Debugger::ReadMemoryRequestT *AsReadMemoryRequest() const {
    return type == Event_ReadMemoryRequest ?
      reinterpret_cast<const Debugger::ReadMemoryRequestT *>(value) : nullptr;
  }
  Debugger::ReadMemoryResponseT *AsReadMemoryResponse() {
    return type == Event_ReadMemoryResponse ?
      reinterpret_cast<Debugger::ReadMemoryResponseT *>(value) : nullptr;
  }
  const Debugger::ReadMemoryResponseT *AsReadMemoryResponse() const {
    return type == Event_ReadMemoryResponse ?
      reinterpret_cast<const Debugger::ReadMemoryResponseT *>(value) : nullptr;
  }
  Debugger::WriteRegisterRequestT *AsWriteRegisterRequest() {
    return type == Event_WriteRegisterRequest ?
      reinterpret_cast<Debugger::WriteRegisterRequestT *>(value) : nullptr;
  }
  const Debugger::WriteRegisterRequestT *AsWriteRegisterRequest() const {
    return type == Event_WriteRegisterRequest ?
      reinterpret_cast<const Debugger::WriteRegisterRequestT *>(value) : nullptr;
  }
  Debugger::WriteRegisterResponseT *AsWriteRegisterResponse() {
    return type == Event_WriteRegisterResponse ?
      reinterpret_cast<Debugger::WriteRegisterResponseT *>(value) : nullptr;
  }
  const Debugger::WriteRegisterResponseT *AsWriteRegisterResponse() const {
    return type == Event_WriteRegisterResponse ?
      reinterpret_cast<const Debugger::WriteRegisterResponseT *>(value) : nullptr;
  }
  Debugger::ReadRegisterRequestT *AsReadRegisterRequest() {
    return type == Event_ReadRegisterRequest ?
      reinterpret_cast<Debugger::ReadRegisterRequestT *>(value) : nullptr;
  }
  const Debugger::ReadRegisterRequestT *AsReadRegisterRequest() const {
    return type == Event_ReadRegisterRequest ?
      reinterpret_cast<const Debugger::ReadRegisterRequestT *>(value) : nullptr;
  }
  Debugger::ReadRegisterResponseT *AsReadRegisterResponse() {
    return type == Event_ReadRegisterResponse ?
      reinterpret_cast<Debugger::ReadRegisterResponseT *>(value) : nullptr;
  }
  const Debugger::ReadRegisterResponseT *AsReadRegisterResponse() const {
    return type == Event_ReadRegisterResponse ?
      reinterpret_cast<const Debugger::ReadRegisterResponseT *>(value) : nullptr;
  }
  Debugger::ApplicationExitT *AsApplicationExit() {
    return type == Event_ApplicationExit ?
      reinterpret_cast<Debugger::ApplicationExitT *>(value) : nullptr;
  }
  const Debugger::ApplicationExitT *AsApplicationExit() const {
    return type == Event_ApplicationExit ?
      reinterpret_cast<const Debugger::ApplicationExitT *>(value) : nullptr;
  }
  Debugger::EmulationStatusT *AsEmulationStatus() {
    return type == Event_EmulationStatus ?
      reinterpret_cast<Debugger::EmulationStatusT *>(value) : nullptr;
  }
  const Debugger::EmulationStatusT *AsEmulationStatus() const {
    return type == Event_EmulationStatus ?
      reinterpret_cast<const Debugger::EmulationStatusT *>(value) : nullptr;
  }
};

bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type);
bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

struct GetStateRequestT : public ::flatbuffers::NativeTable {
  typedef GetStateRequest TableType;
};

struct GetStateRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStateRequestT NativeTableType;
  typedef GetStateRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  GetStateRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetStateRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetStateRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetStateRequestBuilder {
  typedef GetStateRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit GetStateRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStateRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStateRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStateRequest> CreateGetStateRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  GetStateRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<GetStateRequest> CreateGetStateRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GetStateResponseT : public ::flatbuffers::NativeTable {
  typedef GetStateResponse TableType;
  Debugger::State state = Debugger::State_None;
};

struct GetStateResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GetStateResponseT NativeTableType;
  typedef GetStateResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_STATE = 4
  };
  Debugger::State state() const {
    return static_cast<Debugger::State>(GetField<uint32_t>(VT_STATE, 0));
  }
  bool mutate_state(Debugger::State _state = static_cast<Debugger::State>(0)) {
    return SetField<uint32_t>(VT_STATE, static_cast<uint32_t>(_state), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_STATE, 4) &&
           verifier.EndTable();
  }
  GetStateResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GetStateResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<GetStateResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GetStateResponseBuilder {
  typedef GetStateResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_state(Debugger::State state) {
    fbb_.AddElement<uint32_t>(GetStateResponse::VT_STATE, static_cast<uint32_t>(state), 0);
  }
  explicit GetStateResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<GetStateResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<GetStateResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<GetStateResponse> CreateGetStateResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Debugger::State state = Debugger::State_None) {
  GetStateResponseBuilder builder_(_fbb);
  builder_.add_state(state);
  return builder_.Finish();
}

::flatbuffers::Offset<GetStateResponse> CreateGetStateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PauseRequestT : public ::flatbuffers::NativeTable {
  typedef PauseRequest TableType;
};

struct PauseRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PauseRequestT NativeTableType;
  typedef PauseRequestBuilder Builder;
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
  PauseRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PauseRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PauseRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PauseRequestBuilder {
  typedef PauseRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  explicit PauseRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PauseRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PauseRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PauseRequest> CreatePauseRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb) {
  PauseRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

::flatbuffers::Offset<PauseRequest> CreatePauseRequest(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RunRequestT : public ::flatbuffers::NativeTable {
  typedef RunRequest TableType;
  bool single_step = false;
};

struct RunRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RunRequestT NativeTableType;
  typedef RunRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SINGLE_STEP = 4
  };
  bool single_step() const {
    return GetField<uint8_t>(VT_SINGLE_STEP, 0) != 0;
  }
  bool mutate_single_step(bool _single_step = 0) {
    return SetField<uint8_t>(VT_SINGLE_STEP, static_cast<uint8_t>(_single_step), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_SINGLE_STEP, 1) &&
           verifier.EndTable();
  }
  RunRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RunRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RunRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RunRequestBuilder {
  typedef RunRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_single_step(bool single_step) {
    fbb_.AddElement<uint8_t>(RunRequest::VT_SINGLE_STEP, static_cast<uint8_t>(single_step), 0);
  }
  explicit RunRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RunRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RunRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RunRequest> CreateRunRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    bool single_step = false) {
  RunRequestBuilder builder_(_fbb);
  builder_.add_single_step(single_step);
  return builder_.Finish();
}

::flatbuffers::Offset<RunRequest> CreateRunRequest(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteMemoryRequestT : public ::flatbuffers::NativeTable {
  typedef WriteMemoryRequest TableType;
  uint64_t address = 0;
  std::vector<uint8_t> data{};
};

struct WriteMemoryRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteMemoryRequestT NativeTableType;
  typedef WriteMemoryRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_DATA = 6
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  WriteMemoryRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteMemoryRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteMemoryRequestBuilder {
  typedef WriteMemoryRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(WriteMemoryRequest::VT_ADDRESS, address, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteMemoryRequest::VT_DATA, data);
  }
  explicit WriteMemoryRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteMemoryRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteMemoryRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteMemoryRequestBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateWriteMemoryRequest(
      _fbb,
      address,
      data__);
}

::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteMemoryResponseT : public ::flatbuffers::NativeTable {
  typedef WriteMemoryResponse TableType;
  uint64_t address = 0;
  uint32_t size = 0;
  bool success = false;
};

struct WriteMemoryResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteMemoryResponseT NativeTableType;
  typedef WriteMemoryResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6,
    VT_SUCCESS = 8
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success = 0) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  WriteMemoryResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteMemoryResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteMemoryResponseBuilder {
  typedef WriteMemoryResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(WriteMemoryResponse::VT_ADDRESS, address, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(WriteMemoryResponse::VT_SIZE, size, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(WriteMemoryResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit WriteMemoryResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteMemoryResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteMemoryResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteMemoryResponse> CreateWriteMemoryResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t size = 0,
    bool success = false) {
  WriteMemoryResponseBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_size(size);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<WriteMemoryResponse> CreateWriteMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadMemoryRequestT : public ::flatbuffers::NativeTable {
  typedef ReadMemoryRequest TableType;
  uint64_t address = 0;
  uint32_t size = 0;
};

struct ReadMemoryRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadMemoryRequestT NativeTableType;
  typedef ReadMemoryRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           verifier.EndTable();
  }
  ReadMemoryRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadMemoryRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadMemoryRequestBuilder {
  typedef ReadMemoryRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(ReadMemoryRequest::VT_ADDRESS, address, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(ReadMemoryRequest::VT_SIZE, size, 0);
  }
  explicit ReadMemoryRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadMemoryRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadMemoryRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadMemoryRequest> CreateReadMemoryRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t size = 0) {
  ReadMemoryRequestBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_size(size);
  return builder_.Finish();
}

::flatbuffers::Offset<ReadMemoryRequest> CreateReadMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadMemoryResponseT : public ::flatbuffers::NativeTable {
  typedef ReadMemoryResponse TableType;
  uint64_t address = 0;
  std::vector<uint8_t> data{};
};

struct ReadMemoryResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadMemoryResponseT NativeTableType;
  typedef ReadMemoryResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_DATA = 6
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  bool mutate_address(uint64_t _address = 0) {
    return SetField<uint64_t>(VT_ADDRESS, _address, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS, 8) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ReadMemoryResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadMemoryResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadMemoryResponseBuilder {
  typedef ReadMemoryResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(ReadMemoryResponse::VT_ADDRESS, address, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ReadMemoryResponse::VT_DATA, data);
  }
  explicit ReadMemoryResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadMemoryResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadMemoryResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  ReadMemoryResponseBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_data(data);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateReadMemoryResponse(
      _fbb,
      address,
      data__);
}

::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteRegisterRequestT : public ::flatbuffers::NativeTable {
  typedef WriteRegisterRequest TableType;
  uint32_t register_ = 0;
  std::vector<uint8_t> data{};
};

struct WriteRegisterRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteRegisterRequestT NativeTableType;
  typedef WriteRegisterRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4,
    VT_DATA = 6
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  WriteRegisterRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteRegisterRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteRegisterRequestBuilder {
  typedef WriteRegisterRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(WriteRegisterRequest::VT_REGISTER_, register_, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(WriteRegisterRequest::VT_DATA, data);
  }
  explicit WriteRegisterRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteRegisterRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteRegisterRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  WriteRegisterRequestBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_register_(register_);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateWriteRegisterRequest(
      _fbb,
      register_,
      data__);
}

::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct WriteRegisterResponseT : public ::flatbuffers::NativeTable {
  typedef WriteRegisterResponse TableType;
  uint32_t register_ = 0;
  uint32_t size = 0;
  bool success = false;
};

struct WriteRegisterResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef WriteRegisterResponseT NativeTableType;
  typedef WriteRegisterResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4,
    VT_SIZE = 6,
    VT_SUCCESS = 8
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  bool mutate_size(uint32_t _size = 0) {
    return SetField<uint32_t>(VT_SIZE, _size, 0);
  }
  bool success() const {
    return GetField<uint8_t>(VT_SUCCESS, 0) != 0;
  }
  bool mutate_success(bool _success = 0) {
    return SetField<uint8_t>(VT_SUCCESS, static_cast<uint8_t>(_success), 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint8_t>(verifier, VT_SUCCESS, 1) &&
           verifier.EndTable();
  }
  WriteRegisterResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(WriteRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<WriteRegisterResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct WriteRegisterResponseBuilder {
  typedef WriteRegisterResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(WriteRegisterResponse::VT_REGISTER_, register_, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(WriteRegisterResponse::VT_SIZE, size, 0);
  }
  void add_success(bool success) {
    fbb_.AddElement<uint8_t>(WriteRegisterResponse::VT_SUCCESS, static_cast<uint8_t>(success), 0);
  }
  explicit WriteRegisterResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<WriteRegisterResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<WriteRegisterResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<WriteRegisterResponse> CreateWriteRegisterResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    uint32_t size = 0,
    bool success = false) {
  WriteRegisterResponseBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_register_(register_);
  builder_.add_success(success);
  return builder_.Finish();
}

::flatbuffers::Offset<WriteRegisterResponse> CreateWriteRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadRegisterRequestT : public ::flatbuffers::NativeTable {
  typedef ReadRegisterRequest TableType;
  uint32_t register_ = 0;
};

struct ReadRegisterRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadRegisterRequestT NativeTableType;
  typedef ReadRegisterRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           verifier.EndTable();
  }
  ReadRegisterRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadRegisterRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadRegisterRequestBuilder {
  typedef ReadRegisterRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(ReadRegisterRequest::VT_REGISTER_, register_, 0);
  }
  explicit ReadRegisterRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadRegisterRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadRegisterRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadRegisterRequest> CreateReadRegisterRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0) {
  ReadRegisterRequestBuilder builder_(_fbb);
  builder_.add_register_(register_);
  return builder_.Finish();
}

::flatbuffers::Offset<ReadRegisterRequest> CreateReadRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReadRegisterResponseT : public ::flatbuffers::NativeTable {
  typedef ReadRegisterResponse TableType;
  uint32_t register_ = 0;
  std::vector<uint8_t> data{};
};

struct ReadRegisterResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ReadRegisterResponseT NativeTableType;
  typedef ReadRegisterResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REGISTER_ = 4,
    VT_DATA = 6
  };
  uint32_t register_() const {
    return GetField<uint32_t>(VT_REGISTER_, 0);
  }
  bool mutate_register_(uint32_t _register_ = 0) {
    return SetField<uint32_t>(VT_REGISTER_, _register_, 0);
  }
  const ::flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  ::flatbuffers::Vector<uint8_t> *mutable_data() {
    return GetPointer<::flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_REGISTER_, 4) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
  ReadRegisterResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReadRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ReadRegisterResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReadRegisterResponseBuilder {
  typedef ReadRegisterResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_register_(uint32_t register_) {
    fbb_.AddElement<uint32_t>(ReadRegisterResponse::VT_REGISTER_, register_, 0);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(ReadRegisterResponse::VT_DATA, data);
  }
  explicit ReadRegisterResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ReadRegisterResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ReadRegisterResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> data = 0) {
  ReadRegisterResponseBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_register_(register_);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t register_ = 0,
    const std::vector<uint8_t> *data = nullptr) {
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  return Debugger::CreateReadRegisterResponse(
      _fbb,
      register_,
      data__);
}

::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ApplicationExitT : public ::flatbuffers::NativeTable {
  typedef ApplicationExit TableType;
  ::flatbuffers::Optional<uint32_t> exit_status = ::flatbuffers::nullopt;
};

struct ApplicationExit FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ApplicationExitT NativeTableType;
  typedef ApplicationExitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EXIT_STATUS = 4
  };
  ::flatbuffers::Optional<uint32_t> exit_status() const {
    return GetOptional<uint32_t, uint32_t>(VT_EXIT_STATUS);
  }
  bool mutate_exit_status(uint32_t _exit_status) {
    return SetField<uint32_t>(VT_EXIT_STATUS, _exit_status);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EXIT_STATUS, 4) &&
           verifier.EndTable();
  }
  ApplicationExitT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ApplicationExitT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<ApplicationExit> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ApplicationExitBuilder {
  typedef ApplicationExit Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_exit_status(uint32_t exit_status) {
    fbb_.AddElement<uint32_t>(ApplicationExit::VT_EXIT_STATUS, exit_status);
  }
  explicit ApplicationExitBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<ApplicationExit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<ApplicationExit>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<ApplicationExit> CreateApplicationExit(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Optional<uint32_t> exit_status = ::flatbuffers::nullopt) {
  ApplicationExitBuilder builder_(_fbb);
  if(exit_status) { builder_.add_exit_status(*exit_status); }
  return builder_.Finish();
}

::flatbuffers::Offset<ApplicationExit> CreateApplicationExit(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EmulationStatusT : public ::flatbuffers::NativeTable {
  typedef EmulationStatus TableType;
  uint32_t active_threads = 0;
  uint64_t reserved_memory = 0;
  uint64_t committed_memory = 0;
  uint64_t executed_instructions = 0;
};

struct EmulationStatus FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EmulationStatusT NativeTableType;
  typedef EmulationStatusBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVE_THREADS = 4,
    VT_RESERVED_MEMORY = 6,
    VT_COMMITTED_MEMORY = 8,
    VT_EXECUTED_INSTRUCTIONS = 10
  };
  uint32_t active_threads() const {
    return GetField<uint32_t>(VT_ACTIVE_THREADS, 0);
  }
  bool mutate_active_threads(uint32_t _active_threads = 0) {
    return SetField<uint32_t>(VT_ACTIVE_THREADS, _active_threads, 0);
  }
  uint64_t reserved_memory() const {
    return GetField<uint64_t>(VT_RESERVED_MEMORY, 0);
  }
  bool mutate_reserved_memory(uint64_t _reserved_memory = 0) {
    return SetField<uint64_t>(VT_RESERVED_MEMORY, _reserved_memory, 0);
  }
  uint64_t committed_memory() const {
    return GetField<uint64_t>(VT_COMMITTED_MEMORY, 0);
  }
  bool mutate_committed_memory(uint64_t _committed_memory = 0) {
    return SetField<uint64_t>(VT_COMMITTED_MEMORY, _committed_memory, 0);
  }
  uint64_t executed_instructions() const {
    return GetField<uint64_t>(VT_EXECUTED_INSTRUCTIONS, 0);
  }
  bool mutate_executed_instructions(uint64_t _executed_instructions = 0) {
    return SetField<uint64_t>(VT_EXECUTED_INSTRUCTIONS, _executed_instructions, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ACTIVE_THREADS, 4) &&
           VerifyField<uint64_t>(verifier, VT_RESERVED_MEMORY, 8) &&
           VerifyField<uint64_t>(verifier, VT_COMMITTED_MEMORY, 8) &&
           VerifyField<uint64_t>(verifier, VT_EXECUTED_INSTRUCTIONS, 8) &&
           verifier.EndTable();
  }
  EmulationStatusT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EmulationStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EmulationStatus> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EmulationStatusBuilder {
  typedef EmulationStatus Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_active_threads(uint32_t active_threads) {
    fbb_.AddElement<uint32_t>(EmulationStatus::VT_ACTIVE_THREADS, active_threads, 0);
  }
  void add_reserved_memory(uint64_t reserved_memory) {
    fbb_.AddElement<uint64_t>(EmulationStatus::VT_RESERVED_MEMORY, reserved_memory, 0);
  }
  void add_committed_memory(uint64_t committed_memory) {
    fbb_.AddElement<uint64_t>(EmulationStatus::VT_COMMITTED_MEMORY, committed_memory, 0);
  }
  void add_executed_instructions(uint64_t executed_instructions) {
    fbb_.AddElement<uint64_t>(EmulationStatus::VT_EXECUTED_INSTRUCTIONS, executed_instructions, 0);
  }
  explicit EmulationStatusBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EmulationStatus> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EmulationStatus>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EmulationStatus> CreateEmulationStatus(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t active_threads = 0,
    uint64_t reserved_memory = 0,
    uint64_t committed_memory = 0,
    uint64_t executed_instructions = 0) {
  EmulationStatusBuilder builder_(_fbb);
  builder_.add_executed_instructions(executed_instructions);
  builder_.add_committed_memory(committed_memory);
  builder_.add_reserved_memory(reserved_memory);
  builder_.add_active_threads(active_threads);
  return builder_.Finish();
}

::flatbuffers::Offset<EmulationStatus> CreateEmulationStatus(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DebugEventT : public ::flatbuffers::NativeTable {
  typedef DebugEvent TableType;
  Debugger::EventUnion event{};
};

struct DebugEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef DebugEventT NativeTableType;
  typedef DebugEventBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_TYPE = 4,
    VT_EVENT = 6
  };
  Debugger::Event event_type() const {
    return static_cast<Debugger::Event>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const Debugger::PauseRequest *event_as_PauseRequest() const {
    return event_type() == Debugger::Event_PauseRequest ? static_cast<const Debugger::PauseRequest *>(event()) : nullptr;
  }
  const Debugger::RunRequest *event_as_RunRequest() const {
    return event_type() == Debugger::Event_RunRequest ? static_cast<const Debugger::RunRequest *>(event()) : nullptr;
  }
  const Debugger::GetStateRequest *event_as_GetStateRequest() const {
    return event_type() == Debugger::Event_GetStateRequest ? static_cast<const Debugger::GetStateRequest *>(event()) : nullptr;
  }
  const Debugger::GetStateResponse *event_as_GetStateResponse() const {
    return event_type() == Debugger::Event_GetStateResponse ? static_cast<const Debugger::GetStateResponse *>(event()) : nullptr;
  }
  const Debugger::WriteMemoryRequest *event_as_WriteMemoryRequest() const {
    return event_type() == Debugger::Event_WriteMemoryRequest ? static_cast<const Debugger::WriteMemoryRequest *>(event()) : nullptr;
  }
  const Debugger::WriteMemoryResponse *event_as_WriteMemoryResponse() const {
    return event_type() == Debugger::Event_WriteMemoryResponse ? static_cast<const Debugger::WriteMemoryResponse *>(event()) : nullptr;
  }
  const Debugger::ReadMemoryRequest *event_as_ReadMemoryRequest() const {
    return event_type() == Debugger::Event_ReadMemoryRequest ? static_cast<const Debugger::ReadMemoryRequest *>(event()) : nullptr;
  }
  const Debugger::ReadMemoryResponse *event_as_ReadMemoryResponse() const {
    return event_type() == Debugger::Event_ReadMemoryResponse ? static_cast<const Debugger::ReadMemoryResponse *>(event()) : nullptr;
  }
  const Debugger::WriteRegisterRequest *event_as_WriteRegisterRequest() const {
    return event_type() == Debugger::Event_WriteRegisterRequest ? static_cast<const Debugger::WriteRegisterRequest *>(event()) : nullptr;
  }
  const Debugger::WriteRegisterResponse *event_as_WriteRegisterResponse() const {
    return event_type() == Debugger::Event_WriteRegisterResponse ? static_cast<const Debugger::WriteRegisterResponse *>(event()) : nullptr;
  }
  const Debugger::ReadRegisterRequest *event_as_ReadRegisterRequest() const {
    return event_type() == Debugger::Event_ReadRegisterRequest ? static_cast<const Debugger::ReadRegisterRequest *>(event()) : nullptr;
  }
  const Debugger::ReadRegisterResponse *event_as_ReadRegisterResponse() const {
    return event_type() == Debugger::Event_ReadRegisterResponse ? static_cast<const Debugger::ReadRegisterResponse *>(event()) : nullptr;
  }
  const Debugger::ApplicationExit *event_as_ApplicationExit() const {
    return event_type() == Debugger::Event_ApplicationExit ? static_cast<const Debugger::ApplicationExit *>(event()) : nullptr;
  }
  const Debugger::EmulationStatus *event_as_EmulationStatus() const {
    return event_type() == Debugger::Event_EmulationStatus ? static_cast<const Debugger::EmulationStatus *>(event()) : nullptr;
  }
  void *mutable_event() {
    return GetPointer<void *>(VT_EVENT);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvent(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  DebugEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DebugEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<DebugEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const Debugger::PauseRequest *DebugEvent::event_as<Debugger::PauseRequest>() const {
  return event_as_PauseRequest();
}

template<> inline const Debugger::RunRequest *DebugEvent::event_as<Debugger::RunRequest>() const {
  return event_as_RunRequest();
}

template<> inline const Debugger::GetStateRequest *DebugEvent::event_as<Debugger::GetStateRequest>() const {
  return event_as_GetStateRequest();
}

template<> inline const Debugger::GetStateResponse *DebugEvent::event_as<Debugger::GetStateResponse>() const {
  return event_as_GetStateResponse();
}

template<> inline const Debugger::WriteMemoryRequest *DebugEvent::event_as<Debugger::WriteMemoryRequest>() const {
  return event_as_WriteMemoryRequest();
}

template<> inline const Debugger::WriteMemoryResponse *DebugEvent::event_as<Debugger::WriteMemoryResponse>() const {
  return event_as_WriteMemoryResponse();
}

template<> inline const Debugger::ReadMemoryRequest *DebugEvent::event_as<Debugger::ReadMemoryRequest>() const {
  return event_as_ReadMemoryRequest();
}

template<> inline const Debugger::ReadMemoryResponse *DebugEvent::event_as<Debugger::ReadMemoryResponse>() const {
  return event_as_ReadMemoryResponse();
}

template<> inline const Debugger::WriteRegisterRequest *DebugEvent::event_as<Debugger::WriteRegisterRequest>() const {
  return event_as_WriteRegisterRequest();
}

template<> inline const Debugger::WriteRegisterResponse *DebugEvent::event_as<Debugger::WriteRegisterResponse>() const {
  return event_as_WriteRegisterResponse();
}

template<> inline const Debugger::ReadRegisterRequest *DebugEvent::event_as<Debugger::ReadRegisterRequest>() const {
  return event_as_ReadRegisterRequest();
}

template<> inline const Debugger::ReadRegisterResponse *DebugEvent::event_as<Debugger::ReadRegisterResponse>() const {
  return event_as_ReadRegisterResponse();
}

template<> inline const Debugger::ApplicationExit *DebugEvent::event_as<Debugger::ApplicationExit>() const {
  return event_as_ApplicationExit();
}

template<> inline const Debugger::EmulationStatus *DebugEvent::event_as<Debugger::EmulationStatus>() const {
  return event_as_EmulationStatus();
}

struct DebugEventBuilder {
  typedef DebugEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_type(Debugger::Event event_type) {
    fbb_.AddElement<uint8_t>(DebugEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(DebugEvent::VT_EVENT, event);
  }
  explicit DebugEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<DebugEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<DebugEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<DebugEvent> CreateDebugEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    Debugger::Event event_type = Debugger::Event_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  DebugEventBuilder builder_(_fbb);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

::flatbuffers::Offset<DebugEvent> CreateDebugEvent(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline GetStateRequestT *GetStateRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetStateRequestT>(new GetStateRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetStateRequest::UnPackTo(GetStateRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<GetStateRequest> GetStateRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetStateRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetStateRequest> CreateGetStateRequest(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetStateRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return Debugger::CreateGetStateRequest(
      _fbb);
}

inline GetStateResponseT *GetStateResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GetStateResponseT>(new GetStateResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void GetStateResponse::UnPackTo(GetStateResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = state(); _o->state = _e; }
}

inline ::flatbuffers::Offset<GetStateResponse> GetStateResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGetStateResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<GetStateResponse> CreateGetStateResponse(::flatbuffers::FlatBufferBuilder &_fbb, const GetStateResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const GetStateResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _state = _o->state;
  return Debugger::CreateGetStateResponse(
      _fbb,
      _state);
}

inline PauseRequestT *PauseRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PauseRequestT>(new PauseRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PauseRequest::UnPackTo(PauseRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
}

inline ::flatbuffers::Offset<PauseRequest> PauseRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePauseRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PauseRequest> CreatePauseRequest(::flatbuffers::FlatBufferBuilder &_fbb, const PauseRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PauseRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  return Debugger::CreatePauseRequest(
      _fbb);
}

inline RunRequestT *RunRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RunRequestT>(new RunRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RunRequest::UnPackTo(RunRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = single_step(); _o->single_step = _e; }
}

inline ::flatbuffers::Offset<RunRequest> RunRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRunRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RunRequest> CreateRunRequest(::flatbuffers::FlatBufferBuilder &_fbb, const RunRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RunRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _single_step = _o->single_step;
  return Debugger::CreateRunRequest(
      _fbb,
      _single_step);
}

inline WriteMemoryRequestT *WriteMemoryRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteMemoryRequestT>(new WriteMemoryRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteMemoryRequest::UnPackTo(WriteMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<WriteMemoryRequest> WriteMemoryRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWriteMemoryRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteMemoryRequest> CreateWriteMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteMemoryRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateWriteMemoryRequest(
      _fbb,
      _address,
      _data);
}

inline WriteMemoryResponseT *WriteMemoryResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteMemoryResponseT>(new WriteMemoryResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteMemoryResponse::UnPackTo(WriteMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<WriteMemoryResponse> WriteMemoryResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWriteMemoryResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteMemoryResponse> CreateWriteMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteMemoryResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _size = _o->size;
  auto _success = _o->success;
  return Debugger::CreateWriteMemoryResponse(
      _fbb,
      _address,
      _size,
      _success);
}

inline ReadMemoryRequestT *ReadMemoryRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadMemoryRequestT>(new ReadMemoryRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadMemoryRequest::UnPackTo(ReadMemoryRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = size(); _o->size = _e; }
}

inline ::flatbuffers::Offset<ReadMemoryRequest> ReadMemoryRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadMemoryRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadMemoryRequest> CreateReadMemoryRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadMemoryRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _size = _o->size;
  return Debugger::CreateReadMemoryRequest(
      _fbb,
      _address,
      _size);
}

inline ReadMemoryResponseT *ReadMemoryResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadMemoryResponseT>(new ReadMemoryResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadMemoryResponse::UnPackTo(ReadMemoryResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = address(); _o->address = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<ReadMemoryResponse> ReadMemoryResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadMemoryResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadMemoryResponse> CreateReadMemoryResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadMemoryResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadMemoryResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _address = _o->address;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateReadMemoryResponse(
      _fbb,
      _address,
      _data);
}

inline WriteRegisterRequestT *WriteRegisterRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteRegisterRequestT>(new WriteRegisterRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteRegisterRequest::UnPackTo(WriteRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<WriteRegisterRequest> WriteRegisterRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWriteRegisterRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteRegisterRequest> CreateWriteRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteRegisterRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateWriteRegisterRequest(
      _fbb,
      _register_,
      _data);
}

inline WriteRegisterResponseT *WriteRegisterResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<WriteRegisterResponseT>(new WriteRegisterResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void WriteRegisterResponse::UnPackTo(WriteRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
  { auto _e = size(); _o->size = _e; }
  { auto _e = success(); _o->success = _e; }
}

inline ::flatbuffers::Offset<WriteRegisterResponse> WriteRegisterResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateWriteRegisterResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<WriteRegisterResponse> CreateWriteRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const WriteRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const WriteRegisterResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  auto _size = _o->size;
  auto _success = _o->success;
  return Debugger::CreateWriteRegisterResponse(
      _fbb,
      _register_,
      _size,
      _success);
}

inline ReadRegisterRequestT *ReadRegisterRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadRegisterRequestT>(new ReadRegisterRequestT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadRegisterRequest::UnPackTo(ReadRegisterRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
}

inline ::flatbuffers::Offset<ReadRegisterRequest> ReadRegisterRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadRegisterRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadRegisterRequest> CreateReadRegisterRequest(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadRegisterRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  return Debugger::CreateReadRegisterRequest(
      _fbb,
      _register_);
}

inline ReadRegisterResponseT *ReadRegisterResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReadRegisterResponseT>(new ReadRegisterResponseT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ReadRegisterResponse::UnPackTo(ReadRegisterResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = register_(); _o->register_ = _e; }
  { auto _e = data(); if (_e) { _o->data.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->data.begin()); } }
}

inline ::flatbuffers::Offset<ReadRegisterResponse> ReadRegisterResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReadRegisterResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ReadRegisterResponse> CreateReadRegisterResponse(::flatbuffers::FlatBufferBuilder &_fbb, const ReadRegisterResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ReadRegisterResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _register_ = _o->register_;
  auto _data = _o->data.size() ? _fbb.CreateVector(_o->data) : 0;
  return Debugger::CreateReadRegisterResponse(
      _fbb,
      _register_,
      _data);
}

inline ApplicationExitT *ApplicationExit::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ApplicationExitT>(new ApplicationExitT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ApplicationExit::UnPackTo(ApplicationExitT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = exit_status(); _o->exit_status = _e; }
}

inline ::flatbuffers::Offset<ApplicationExit> ApplicationExit::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateApplicationExit(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<ApplicationExit> CreateApplicationExit(::flatbuffers::FlatBufferBuilder &_fbb, const ApplicationExitT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const ApplicationExitT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _exit_status = _o->exit_status;
  return Debugger::CreateApplicationExit(
      _fbb,
      _exit_status);
}

inline EmulationStatusT *EmulationStatus::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EmulationStatusT>(new EmulationStatusT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EmulationStatus::UnPackTo(EmulationStatusT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = active_threads(); _o->active_threads = _e; }
  { auto _e = reserved_memory(); _o->reserved_memory = _e; }
  { auto _e = committed_memory(); _o->committed_memory = _e; }
  { auto _e = executed_instructions(); _o->executed_instructions = _e; }
}

inline ::flatbuffers::Offset<EmulationStatus> EmulationStatus::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEmulationStatus(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EmulationStatus> CreateEmulationStatus(::flatbuffers::FlatBufferBuilder &_fbb, const EmulationStatusT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EmulationStatusT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _active_threads = _o->active_threads;
  auto _reserved_memory = _o->reserved_memory;
  auto _committed_memory = _o->committed_memory;
  auto _executed_instructions = _o->executed_instructions;
  return Debugger::CreateEmulationStatus(
      _fbb,
      _active_threads,
      _reserved_memory,
      _committed_memory,
      _executed_instructions);
}

inline DebugEventT *DebugEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DebugEventT>(new DebugEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DebugEvent::UnPackTo(DebugEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_type(); _o->event.type = _e; }
  { auto _e = event(); if (_e) _o->event.value = Debugger::EventUnion::UnPack(_e, event_type(), _resolver); }
}

inline ::flatbuffers::Offset<DebugEvent> DebugEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDebugEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<DebugEvent> CreateDebugEvent(::flatbuffers::FlatBufferBuilder &_fbb, const DebugEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const DebugEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return Debugger::CreateDebugEvent(
      _fbb,
      _event_type,
      _event);
}

inline bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type) {
  switch (type) {
    case Event_NONE: {
      return true;
    }
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<const Debugger::PauseRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<const Debugger::RunRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<const Debugger::GetStateRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<const Debugger::GetStateResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<const Debugger::ApplicationExit *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<const Debugger::EmulationStatus *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvent(
        verifier,  values->Get(i), types->GetEnum<Event>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventUnion::UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<const Debugger::PauseRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<const Debugger::RunRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<const Debugger::GetStateRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<const Debugger::GetStateResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterRequest *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterResponse *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<const Debugger::ApplicationExit *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<const Debugger::EmulationStatus *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> EventUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<const Debugger::PauseRequestT *>(value);
      return CreatePauseRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<const Debugger::RunRequestT *>(value);
      return CreateRunRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<const Debugger::GetStateRequestT *>(value);
      return CreateGetStateRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<const Debugger::GetStateResponseT *>(value);
      return CreateGetStateResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryRequestT *>(value);
      return CreateWriteMemoryRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteMemoryResponseT *>(value);
      return CreateWriteMemoryResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryRequestT *>(value);
      return CreateReadMemoryRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadMemoryResponseT *>(value);
      return CreateReadMemoryResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterRequestT *>(value);
      return CreateWriteRegisterRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::WriteRegisterResponseT *>(value);
      return CreateWriteRegisterResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterRequestT *>(value);
      return CreateReadRegisterRequest(_fbb, ptr, _rehasher).Union();
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<const Debugger::ReadRegisterResponseT *>(value);
      return CreateReadRegisterResponse(_fbb, ptr, _rehasher).Union();
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<const Debugger::ApplicationExitT *>(value);
      return CreateApplicationExit(_fbb, ptr, _rehasher).Union();
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<const Debugger::EmulationStatusT *>(value);
      return CreateEmulationStatus(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventUnion::EventUnion(const EventUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Event_PauseRequest: {
      value = new Debugger::PauseRequestT(*reinterpret_cast<Debugger::PauseRequestT *>(u.value));
      break;
    }
    case Event_RunRequest: {
      value = new Debugger::RunRequestT(*reinterpret_cast<Debugger::RunRequestT *>(u.value));
      break;
    }
    case Event_GetStateRequest: {
      value = new Debugger::GetStateRequestT(*reinterpret_cast<Debugger::GetStateRequestT *>(u.value));
      break;
    }
    case Event_GetStateResponse: {
      value = new Debugger::GetStateResponseT(*reinterpret_cast<Debugger::GetStateResponseT *>(u.value));
      break;
    }
    case Event_WriteMemoryRequest: {
      value = new Debugger::WriteMemoryRequestT(*reinterpret_cast<Debugger::WriteMemoryRequestT *>(u.value));
      break;
    }
    case Event_WriteMemoryResponse: {
      value = new Debugger::WriteMemoryResponseT(*reinterpret_cast<Debugger::WriteMemoryResponseT *>(u.value));
      break;
    }
    case Event_ReadMemoryRequest: {
      value = new Debugger::ReadMemoryRequestT(*reinterpret_cast<Debugger::ReadMemoryRequestT *>(u.value));
      break;
    }
    case Event_ReadMemoryResponse: {
      value = new Debugger::ReadMemoryResponseT(*reinterpret_cast<Debugger::ReadMemoryResponseT *>(u.value));
      break;
    }
    case Event_WriteRegisterRequest: {
      value = new Debugger::WriteRegisterRequestT(*reinterpret_cast<Debugger::WriteRegisterRequestT *>(u.value));
      break;
    }
    case Event_WriteRegisterResponse: {
      value = new Debugger::WriteRegisterResponseT(*reinterpret_cast<Debugger::WriteRegisterResponseT *>(u.value));
      break;
    }
    case Event_ReadRegisterRequest: {
      value = new Debugger::ReadRegisterRequestT(*reinterpret_cast<Debugger::ReadRegisterRequestT *>(u.value));
      break;
    }
    case Event_ReadRegisterResponse: {
      value = new Debugger::ReadRegisterResponseT(*reinterpret_cast<Debugger::ReadRegisterResponseT *>(u.value));
      break;
    }
    case Event_ApplicationExit: {
      value = new Debugger::ApplicationExitT(*reinterpret_cast<Debugger::ApplicationExitT *>(u.value));
      break;
    }
    case Event_EmulationStatus: {
      value = new Debugger::EmulationStatusT(*reinterpret_cast<Debugger::EmulationStatusT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventUnion::Reset() {
  switch (type) {
    case Event_PauseRequest: {
      auto ptr = reinterpret_cast<Debugger::PauseRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_RunRequest: {
      auto ptr = reinterpret_cast<Debugger::RunRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_GetStateRequest: {
      auto ptr = reinterpret_cast<Debugger::GetStateRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_GetStateResponse: {
      auto ptr = reinterpret_cast<Debugger::GetStateResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteMemoryRequest: {
      auto ptr = reinterpret_cast<Debugger::WriteMemoryRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteMemoryResponse: {
      auto ptr = reinterpret_cast<Debugger::WriteMemoryResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadMemoryRequest: {
      auto ptr = reinterpret_cast<Debugger::ReadMemoryRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadMemoryResponse: {
      auto ptr = reinterpret_cast<Debugger::ReadMemoryResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteRegisterRequest: {
      auto ptr = reinterpret_cast<Debugger::WriteRegisterRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_WriteRegisterResponse: {
      auto ptr = reinterpret_cast<Debugger::WriteRegisterResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadRegisterRequest: {
      auto ptr = reinterpret_cast<Debugger::ReadRegisterRequestT *>(value);
      delete ptr;
      break;
    }
    case Event_ReadRegisterResponse: {
      auto ptr = reinterpret_cast<Debugger::ReadRegisterResponseT *>(value);
      delete ptr;
      break;
    }
    case Event_ApplicationExit: {
      auto ptr = reinterpret_cast<Debugger::ApplicationExitT *>(value);
      delete ptr;
      break;
    }
    case Event_EmulationStatus: {
      auto ptr = reinterpret_cast<Debugger::EmulationStatusT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Event_NONE;
}

inline const Debugger::DebugEvent *GetDebugEvent(const void *buf) {
  return ::flatbuffers::GetRoot<Debugger::DebugEvent>(buf);
}

inline const Debugger::DebugEvent *GetSizePrefixedDebugEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<Debugger::DebugEvent>(buf);
}

inline DebugEvent *GetMutableDebugEvent(void *buf) {
  return ::flatbuffers::GetMutableRoot<DebugEvent>(buf);
}

inline Debugger::DebugEvent *GetMutableSizePrefixedDebugEvent(void *buf) {
  return ::flatbuffers::GetMutableSizePrefixedRoot<Debugger::DebugEvent>(buf);
}

inline bool VerifyDebugEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Debugger::DebugEvent>(nullptr);
}

inline bool VerifySizePrefixedDebugEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Debugger::DebugEvent>(nullptr);
}

inline void FinishDebugEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Debugger::DebugEvent> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedDebugEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<Debugger::DebugEvent> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<Debugger::DebugEventT> UnPackDebugEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Debugger::DebugEventT>(GetDebugEvent(buf)->UnPack(res));
}

inline std::unique_ptr<Debugger::DebugEventT> UnPackSizePrefixedDebugEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<Debugger::DebugEventT>(GetSizePrefixedDebugEvent(buf)->UnPack(res));
}

}  // namespace Debugger

#endif  // FLATBUFFERS_GENERATED_EVENTS_DEBUGGER_H_
